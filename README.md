# OOD-Tamrin-02
# سیستم مدیریت تیکت – الگوهای طراحی و اصول طراحی

## معرفی کلی

این پروژه یک **سیستم ساده‌ی مدیریت تیکت** را پیاده‌سازی می‌کند که درخواست‌های کاربران را از کانال‌های مختلف (WEB / EMAIL) دریافت و پردازش می‌کند. در طول انجام پروژه، کد به‌صورت مرحله‌به‌مرحله بازطراحی (Refactor) شده و از **الگوهای متداول طراحی شی‌گرا** برای بهبود کیفیت طراحی استفاده شده است.

در نسخه نهایی، الگوهای **State**، **Strategy** و **Factory** به‌کار رفته‌اند و تلاش شده اصول مهم طراحی شی‌گرا مطابق مطالب ارائه‌شده در درس رعایت شوند.

> ⚠️ **نکته مهم:** در این پروژه از **هوش مصنوعی صرفاً به‌عنوان ابزار کمکی برای نوشتن سینتکس زبان Java و ساختاردهی کدها** استفاده شده است. انتخاب الگوهای طراحی، تصمیمات معماری و تحلیل طراحی به‌صورت کامل توسط دانشجو انجام شده است.

---

## الگوهای طراحی استفاده‌شده

### 1. الگوی State (چرخه حیات تیکت)

**مسئله:**
در نسخه اولیه، منطق پردازش تیکت‌ها با استفاده از چندین شرط `if` بر اساس وضعیت تیکت پیاده‌سازی شده بود. این روش باعث:

* پیچیدگی کد
* وابستگی شدید منطق به وضعیت‌ها
* سختی توسعه و نگهداری

**راه‌حل:**
با استفاده از **الگوی State**، رفتار مربوط به هر وضعیت تیکت در یک کلاس جداگانه کپسوله شد.

**وضعیت‌های پیاده‌سازی‌شده:**

* `NewState`
* `AssignedState`
* `InProgressState`
* `ResolvedState`
* `ClosedState`

هر وضعیت، رفتار مخصوص خود و انتقال به وضعیت بعدی را مدیریت می‌کند.

**مزایا:**

* حذف شرط‌های پیچیده
* افزایش خوانایی کد
* امکان افزودن وضعیت‌های جدید بدون تغییر کدهای قبلی

---

### 2. الگوی Strategy (تعیین واحد مسئول و نوع پاسخ)

**مسئله:**
منطق تعیین واحد رسیدگی (Engineering / Support) و همچنین تولید پاسخ مناسب، وابسته به نوع تیکت بود و با شرط‌های مستقیم پیاده‌سازی شده بود.

**راه‌حل:**
با استفاده از **الگوی Strategy**، این رفتارها به‌صورت قابل‌تعویض و مستقل پیاده‌سازی شدند.

**Strategyهای پیاده‌سازی‌شده:**

* `AssignmentStrategy` برای تعیین واحد مسئول رسیدگی
* `ResponseStrategy` برای تولید پاسخ مناسب

این Strategyها در زمان اجرا به سیستم تزریق می‌شوند و Stateها از آن‌ها استفاده می‌کنند.

**مزایا:**

* رعایت اصل Open/Closed
* حذف شرط‌های وابسته به نوع تیکت
* افزایش انعطاف‌پذیری سیستم

---

### 3. الگوی Factory (ایجاد تیکت بر اساس کانال ورودی)

**مسئله:**
ایجاد مستقیم تیکت‌ها در کلاس `Main` باعث وابستگی لایه ورودی به جزئیات ساخت شیء می‌شد و توسعه‌ی آینده را سخت می‌کرد.

**راه‌حل:**
برای حل این مشکل از **الگوی Factory** استفاده شد تا منطق ساخت تیکت در یک محل متمرکز شود.

**Factory پیاده‌سازی‌شده:**

* `TicketFactory`
* `ChannelBasedTicketFactory`

این Factory امکان پردازش اولیه متفاوت برای کانال‌های WEB و EMAIL را فراهم می‌کند.

**مزایا:**

* جداسازی منطق ساخت شیء از منطق برنامه
* افزایش خوانایی و توسعه‌پذیری
* رعایت بهتر اصل SRP

---

## اصول طراحی رعایت‌شده

### اصل Single Responsibility (SRP)

* هر کلاس تنها یک مسئولیت مشخص دارد
* مدیریت وضعیت، تعیین واحد رسیدگی، تولید پاسخ، لاگ‌گیری و ساخت تیکت از هم جدا شده‌اند

### اصل Open/Closed (OCP)

* افزودن وضعیت یا Strategy جدید بدون تغییر در کدهای قبلی امکان‌پذیر است

### اصل Principle of Least Knowledge (PLK)

* کلاس‌ها تنها با وابستگی‌های مستقیم خود در ارتباط هستند
* `TicketService` فقط هماهنگ‌کننده است و جزئیات را مدیریت نمی‌کند

### اصل Common Reuse Principle (CRP)

* کلاس‌های مرتبط در پکیج‌های مجزا (state، strategy، factory) گروه‌بندی شده‌اند
* تغییرات روی بخش‌های غیرمرتبط تأثیر نمی‌گذارد

---

## جمع‌بندی نهایی

با استفاده از الگوهای طراحی و اصول شی‌گرایی:

* ساختار کد خواناتر و منظم‌تر شده است
* پیچیدگی شرط‌ها حذف شده است
* سیستم قابلیت توسعه و نگهداری بهتری پیدا کرده است

این پروژه نمونه‌ای عملی از کاربرد **الگوهای State، Strategy و Factory** در یک سناریوی واقعی محسوب می‌شود.